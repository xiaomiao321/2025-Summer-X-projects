# 「寓教于乐」经典游戏合辑的技术实现

## 一、模块概述

游戏是检验一个嵌入式系统综合能力（计算、IO、实时响应）的试金石，也是最能吸引用户的功能。本模块在小小的时钟屏幕上，复刻了多款经典的迷你游戏，为用户提供了丰富的娱乐体验。

我们没有为每个游戏都创建一个独立的、庞大的状态机，而是将它们统一在`GamesMenu`的管理之下。用户可以在一个横向滚动的游戏列表中选择自己想玩的游戏，按下按钮即可启动。每个游戏都是一个独立的函数，拥有自己的主循环和逻辑，游戏结束后，程序会优雅地返回到游戏选择菜单。本篇将重点解析菜单中包含的四款游戏的核心实现思路。

## 二、游戏核心思路解析

### 1. 康威生命游戏 (Conway's Game of Life)

生命游戏不是一个传统意义上需要“玩”的游戏，而是一个“元胞自动机”的模拟器。它在一个二维网格上，根据几条简单的规则，模拟生命的演化、繁荣与衰亡，能涌现出各种令人惊叹的复杂模式。

-   **数据结构**：我们使用了两个二维布尔数组，`grid[GRID_SIZE][GRID_SIZE]`和`nextGrid[GRID_SIZE][GRID_SIZE]`。`grid`代表当前时刻所有细胞的“生/死”状态，`nextGrid`则用于计算并存储下一时刻的状态。
-   **核心算法**：游戏的核心是`updateConwayGrid()`函数。它遍历当前`grid`中的每一个细胞，然后检查其周围的8个邻居，统计“活”邻居的数量。根据生命游戏的经典规则（“孤独死”、“拥挤死”、“恰好生”），来决定这个细胞在`nextGrid`中的下一状态是生是死。
-   **双缓冲**：`grid`和`nextGrid`的使用，构成了典型的“双缓冲”模式。我们不能在遍历`grid`的同时直接修改它，因为这会影响到后续细胞的邻居判断。正确的做法是，所有下一代的状态都先写入`nextGrid`。当所有细胞都计算完毕后，再将`nextGrid`的内容完整地复制回`grid`，完成一次“代”的演化。这保证了演化计算的原子性和正确性。(生命游戏是算法和计算思维的绝佳入门，可以在[维基百科](https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F)上了解它的迷人之处)
-   **交互**：此游戏是自动运行的，用户是观察者。唯一的交互是双击按钮退出模拟。

### 2. 蜂鸣器节拍 (Buzzer Tap)

这是一个考验玩家反应速度的节奏游戏。程序会以随机的时间间隔发出一声短促的提示音，玩家需要在提示音响起后的一个极短的时间窗口内（本项目中为300毫秒）按下按钮，成功则得分，否则失败。

-   **核心逻辑**：游戏的主循环中，通过`millis()`函数来判断是否到达了下一次播放提示音的时刻（`if (currentTime - lastToneTime > nextToneInterval)`）。提示音的间隔`nextToneInterval`在每次播放后都会重新随机生成，让玩家无法预测。
-   **得分判断**：当玩家按下按钮时，程序会立刻检查当前`millis()`距离上次提示音响起的时间（`currentTime - lastToneTime`）是否在有效的`TAP_WINDOW_MS`之内。如果是，则判定为成功，分数增加并播放一个“成功”的音效；如果不是，则播放“失败”的音效。这个时间差的判断是游戏玩法的核心。

### 3. 时间挑战 (Time Challenge)

这是一款挑战玩家对时间流逝感知的游戏。游戏开始时，屏幕上会显示一个随机的目标时间（如12.5秒）。一个计时器会从0开始计时，但这个计时器在达到目标时间后并不会停止，而是会继续走下去。玩家的目标是在心中默数，并尽可能在计时器走到目标时间的瞬间按下按钮。

-   **核心逻辑**：游戏开始时，记录下`startTime`和随机生成的目标时长`targetTimeMs`。在主循环中，不断地计算`elapsedSec = (millis() - startTime) / 1000.0`并显示在屏幕上。
-   **胜负判断**：游戏不限制玩家何时按下按钮。当玩家按下按钮后，程序记录下`pressTime`，然后计算玩家按下的时间与目标时间的差值 `diffSec = (pressTime - startTime) - targetTimeMs`。这个差值的绝对值越小，说明玩家对时间的感知越准。游戏的目的就是挑战获得尽可能小的差值。
-   **视觉辅助**：为了帮助玩家感知时间，我们增加了一个与目标时间同步的进度条，并在计时过程中每秒发出一次“滴答”声，这些都是提升用户体验的细节。

### 4. 像素鸟 (Flappy Bird)

这是一款现象级的、操作简单但难度极高的经典小游戏。玩家通过不断点击按钮，控制一只小鸟上下飞行，穿过无穷无尽的、间隙位置随机的管道。

-   **物理模型**：小鸟的运动是游戏的核心。我们为小鸟设置了Y轴坐标`bird_y`和Y轴速度`bird_vy`。在每一帧，我们都会模拟重力，让速度`bird_vy`增加一个固定的重力值`GRAVITY`，然后根据新的速度更新小鸟的坐标`bird_y += bird_vy`。当玩家按下按钮时，我们会给`bird_vy`一个瞬时的、向上的负值`JUMP_FORCE`，来模拟“扇动翅膀”的跳跃。这个简单的“重力-跳跃”模型，构成了游戏的基本物理引擎。
-   **关卡生成**：管道是无穷无尽的。我们只用了两个管道对象。当一个管道完全移出屏幕左侧时（`pipes_x[i] < -PIPE_WIDTH`），我们并不会销毁它，而是将其“传送”回屏幕的右侧，并为其随机生成一个新的缺口高度。通过这种循环利用对象的方式，我们用极小的内存开销，实现了无限滚动的关卡。
-   **碰撞检测**：在每一帧，我们都会进行矩形碰撞检测。检查小鸟的包围盒（`BIRD_X`加减`BIRD_RADIUS`）是否与上下管道的矩形区域有重叠。一旦检测到重叠，或小鸟飞出了屏幕的上下边界，就将游戏状态设为`game_over`。

## 四、总结与展望

游戏模块是展示嵌入式系统软硬件结合能力的最佳舞台。通过实现这几款经典游戏，我们不仅锻炼了算法逻辑（生命游戏）、实时事件处理（节拍游戏）、物理模拟（像素鸟）等多种编程技巧，也为用户提供了丰富的娱乐内容。将复杂的游戏逻辑封装在独立的函数中，使得整个游戏模块结构清晰，易于未来添加更多的新游戏。

未来的可扩展方向非常广阔：
-   **更多经典游戏**：可以继续复刻如“贪吃蛇”、“俄罗斯方块”、“打砖块”等更多经典游戏。
-   **排行榜/高分记录**：为有得分机制的游戏（如像素鸟、节拍游戏）增加高分记录功能，使用EEPROM将最高分持久化保存，增加玩家的挑战欲望。
-   **难度选择**：为游戏增加简单、普通、困难等难度选项，例如改变像素鸟的管道间距或移动速度。